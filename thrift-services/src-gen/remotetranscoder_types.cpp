/**
 * Autogenerated by Thrift Compiler (0.21.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "remotetranscoder_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace remotetranscoder {


ProbeType::~ProbeType() noexcept {
}

ProbeType::ProbeType() noexcept
   : url(),
     cookies(),
     referer(),
     userAgent(),
     responseIp(),
     responsePort(),
     vdrIp(),
     vdrPort(),
     postfix() {
}

void ProbeType::__set_url(const std::string& val) {
  this->url = val;
}

void ProbeType::__set_cookies(const std::string& val) {
  this->cookies = val;
}

void ProbeType::__set_referer(const std::string& val) {
  this->referer = val;
}

void ProbeType::__set_userAgent(const std::string& val) {
  this->userAgent = val;
}

void ProbeType::__set_responseIp(const std::string& val) {
  this->responseIp = val;
}

void ProbeType::__set_responsePort(const std::string& val) {
  this->responsePort = val;
}

void ProbeType::__set_vdrIp(const std::string& val) {
  this->vdrIp = val;
}

void ProbeType::__set_vdrPort(const std::string& val) {
  this->vdrPort = val;
}

void ProbeType::__set_postfix(const std::string& val) {
  this->postfix = val;
}
std::ostream& operator<<(std::ostream& out, const ProbeType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ProbeType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cookies);
          this->__isset.cookies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->referer);
          this->__isset.referer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userAgent);
          this->__isset.userAgent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->responseIp);
          this->__isset.responseIp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->responsePort);
          this->__isset.responsePort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vdrIp);
          this->__isset.vdrIp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vdrPort);
          this->__isset.vdrPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->postfix);
          this->__isset.postfix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ProbeType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ProbeType");

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cookies", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->cookies);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("referer", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->referer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userAgent", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->userAgent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("responseIp", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->responseIp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("responsePort", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->responsePort);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vdrIp", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->vdrIp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vdrPort", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->vdrPort);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("postfix", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->postfix);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ProbeType &a, ProbeType &b) {
  using ::std::swap;
  swap(a.url, b.url);
  swap(a.cookies, b.cookies);
  swap(a.referer, b.referer);
  swap(a.userAgent, b.userAgent);
  swap(a.responseIp, b.responseIp);
  swap(a.responsePort, b.responsePort);
  swap(a.vdrIp, b.vdrIp);
  swap(a.vdrPort, b.vdrPort);
  swap(a.postfix, b.postfix);
  swap(a.__isset, b.__isset);
}

bool ProbeType::operator==(const ProbeType & rhs) const
{
  if (!(url == rhs.url))
    return false;
  if (!(cookies == rhs.cookies))
    return false;
  if (!(referer == rhs.referer))
    return false;
  if (!(userAgent == rhs.userAgent))
    return false;
  if (!(responseIp == rhs.responseIp))
    return false;
  if (!(responsePort == rhs.responsePort))
    return false;
  if (!(vdrIp == rhs.vdrIp))
    return false;
  if (!(vdrPort == rhs.vdrPort))
    return false;
  if (!(postfix == rhs.postfix))
    return false;
  return true;
}

ProbeType::ProbeType(const ProbeType& other0) {
  url = other0.url;
  cookies = other0.cookies;
  referer = other0.referer;
  userAgent = other0.userAgent;
  responseIp = other0.responseIp;
  responsePort = other0.responsePort;
  vdrIp = other0.vdrIp;
  vdrPort = other0.vdrPort;
  postfix = other0.postfix;
  __isset = other0.__isset;
}
ProbeType& ProbeType::operator=(const ProbeType& other1) {
  url = other1.url;
  cookies = other1.cookies;
  referer = other1.referer;
  userAgent = other1.userAgent;
  responseIp = other1.responseIp;
  responsePort = other1.responsePort;
  vdrIp = other1.vdrIp;
  vdrPort = other1.vdrPort;
  postfix = other1.postfix;
  __isset = other1.__isset;
  return *this;
}
void ProbeType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ProbeType(";
  out << "url=" << to_string(url);
  out << ", " << "cookies=" << to_string(cookies);
  out << ", " << "referer=" << to_string(referer);
  out << ", " << "userAgent=" << to_string(userAgent);
  out << ", " << "responseIp=" << to_string(responseIp);
  out << ", " << "responsePort=" << to_string(responsePort);
  out << ", " << "vdrIp=" << to_string(vdrIp);
  out << ", " << "vdrPort=" << to_string(vdrPort);
  out << ", " << "postfix=" << to_string(postfix);
  out << ")";
}


StreamUrlType::~StreamUrlType() noexcept {
}

StreamUrlType::StreamUrlType() noexcept
   : url(),
     cookies(),
     referer(),
     userAgent(),
     responseIp(),
     responsePort(),
     vdrIp(),
     vdrPort(),
     mpdStart() {
}

void StreamUrlType::__set_url(const std::string& val) {
  this->url = val;
}

void StreamUrlType::__set_cookies(const std::string& val) {
  this->cookies = val;
}

void StreamUrlType::__set_referer(const std::string& val) {
  this->referer = val;
}

void StreamUrlType::__set_userAgent(const std::string& val) {
  this->userAgent = val;
}

void StreamUrlType::__set_responseIp(const std::string& val) {
  this->responseIp = val;
}

void StreamUrlType::__set_responsePort(const std::string& val) {
  this->responsePort = val;
}

void StreamUrlType::__set_vdrIp(const std::string& val) {
  this->vdrIp = val;
}

void StreamUrlType::__set_vdrPort(const std::string& val) {
  this->vdrPort = val;
}

void StreamUrlType::__set_mpdStart(const std::string& val) {
  this->mpdStart = val;
}
std::ostream& operator<<(std::ostream& out, const StreamUrlType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StreamUrlType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cookies);
          this->__isset.cookies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->referer);
          this->__isset.referer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userAgent);
          this->__isset.userAgent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->responseIp);
          this->__isset.responseIp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->responsePort);
          this->__isset.responsePort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vdrIp);
          this->__isset.vdrIp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vdrPort);
          this->__isset.vdrPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mpdStart);
          this->__isset.mpdStart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StreamUrlType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StreamUrlType");

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cookies", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->cookies);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("referer", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->referer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userAgent", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->userAgent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("responseIp", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->responseIp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("responsePort", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->responsePort);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vdrIp", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->vdrIp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vdrPort", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->vdrPort);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mpdStart", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->mpdStart);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StreamUrlType &a, StreamUrlType &b) {
  using ::std::swap;
  swap(a.url, b.url);
  swap(a.cookies, b.cookies);
  swap(a.referer, b.referer);
  swap(a.userAgent, b.userAgent);
  swap(a.responseIp, b.responseIp);
  swap(a.responsePort, b.responsePort);
  swap(a.vdrIp, b.vdrIp);
  swap(a.vdrPort, b.vdrPort);
  swap(a.mpdStart, b.mpdStart);
  swap(a.__isset, b.__isset);
}

bool StreamUrlType::operator==(const StreamUrlType & rhs) const
{
  if (!(url == rhs.url))
    return false;
  if (!(cookies == rhs.cookies))
    return false;
  if (!(referer == rhs.referer))
    return false;
  if (!(userAgent == rhs.userAgent))
    return false;
  if (!(responseIp == rhs.responseIp))
    return false;
  if (!(responsePort == rhs.responsePort))
    return false;
  if (!(vdrIp == rhs.vdrIp))
    return false;
  if (!(vdrPort == rhs.vdrPort))
    return false;
  if (!(mpdStart == rhs.mpdStart))
    return false;
  return true;
}

StreamUrlType::StreamUrlType(const StreamUrlType& other2) {
  url = other2.url;
  cookies = other2.cookies;
  referer = other2.referer;
  userAgent = other2.userAgent;
  responseIp = other2.responseIp;
  responsePort = other2.responsePort;
  vdrIp = other2.vdrIp;
  vdrPort = other2.vdrPort;
  mpdStart = other2.mpdStart;
  __isset = other2.__isset;
}
StreamUrlType& StreamUrlType::operator=(const StreamUrlType& other3) {
  url = other3.url;
  cookies = other3.cookies;
  referer = other3.referer;
  userAgent = other3.userAgent;
  responseIp = other3.responseIp;
  responsePort = other3.responsePort;
  vdrIp = other3.vdrIp;
  vdrPort = other3.vdrPort;
  mpdStart = other3.mpdStart;
  __isset = other3.__isset;
  return *this;
}
void StreamUrlType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StreamUrlType(";
  out << "url=" << to_string(url);
  out << ", " << "cookies=" << to_string(cookies);
  out << ", " << "referer=" << to_string(referer);
  out << ", " << "userAgent=" << to_string(userAgent);
  out << ", " << "responseIp=" << to_string(responseIp);
  out << ", " << "responsePort=" << to_string(responsePort);
  out << ", " << "vdrIp=" << to_string(vdrIp);
  out << ", " << "vdrPort=" << to_string(vdrPort);
  out << ", " << "mpdStart=" << to_string(mpdStart);
  out << ")";
}


PauseType::~PauseType() noexcept {
}

PauseType::PauseType() noexcept
   : streamId() {
}

void PauseType::__set_streamId(const std::string& val) {
  this->streamId = val;
}
std::ostream& operator<<(std::ostream& out, const PauseType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PauseType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->streamId);
          this->__isset.streamId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PauseType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PauseType");

  xfer += oprot->writeFieldBegin("streamId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->streamId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PauseType &a, PauseType &b) {
  using ::std::swap;
  swap(a.streamId, b.streamId);
  swap(a.__isset, b.__isset);
}

bool PauseType::operator==(const PauseType & rhs) const
{
  if (!(streamId == rhs.streamId))
    return false;
  return true;
}

PauseType::PauseType(const PauseType& other4) {
  streamId = other4.streamId;
  __isset = other4.__isset;
}
PauseType& PauseType::operator=(const PauseType& other5) {
  streamId = other5.streamId;
  __isset = other5.__isset;
  return *this;
}
void PauseType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PauseType(";
  out << "streamId=" << to_string(streamId);
  out << ")";
}


SeekToType::~SeekToType() noexcept {
}

SeekToType::SeekToType() noexcept
   : streamId(),
     seekTo() {
}

void SeekToType::__set_streamId(const std::string& val) {
  this->streamId = val;
}

void SeekToType::__set_seekTo(const std::string& val) {
  this->seekTo = val;
}
std::ostream& operator<<(std::ostream& out, const SeekToType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SeekToType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->streamId);
          this->__isset.streamId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->seekTo);
          this->__isset.seekTo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SeekToType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SeekToType");

  xfer += oprot->writeFieldBegin("streamId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->streamId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("seekTo", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->seekTo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SeekToType &a, SeekToType &b) {
  using ::std::swap;
  swap(a.streamId, b.streamId);
  swap(a.seekTo, b.seekTo);
  swap(a.__isset, b.__isset);
}

bool SeekToType::operator==(const SeekToType & rhs) const
{
  if (!(streamId == rhs.streamId))
    return false;
  if (!(seekTo == rhs.seekTo))
    return false;
  return true;
}

SeekToType::SeekToType(const SeekToType& other6) {
  streamId = other6.streamId;
  seekTo = other6.seekTo;
  __isset = other6.__isset;
}
SeekToType& SeekToType::operator=(const SeekToType& other7) {
  streamId = other7.streamId;
  seekTo = other7.seekTo;
  __isset = other7.__isset;
  return *this;
}
void SeekToType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SeekToType(";
  out << "streamId=" << to_string(streamId);
  out << ", " << "seekTo=" << to_string(seekTo);
  out << ")";
}


ResumeType::~ResumeType() noexcept {
}

ResumeType::ResumeType() noexcept
   : streamId(),
     position() {
}

void ResumeType::__set_streamId(const std::string& val) {
  this->streamId = val;
}

void ResumeType::__set_position(const std::string& val) {
  this->position = val;
}
std::ostream& operator<<(std::ostream& out, const ResumeType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResumeType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->streamId);
          this->__isset.streamId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->position);
          this->__isset.position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ResumeType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResumeType");

  xfer += oprot->writeFieldBegin("streamId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->streamId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->position);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResumeType &a, ResumeType &b) {
  using ::std::swap;
  swap(a.streamId, b.streamId);
  swap(a.position, b.position);
  swap(a.__isset, b.__isset);
}

bool ResumeType::operator==(const ResumeType & rhs) const
{
  if (!(streamId == rhs.streamId))
    return false;
  if (!(position == rhs.position))
    return false;
  return true;
}

ResumeType::ResumeType(const ResumeType& other8) {
  streamId = other8.streamId;
  position = other8.position;
  __isset = other8.__isset;
}
ResumeType& ResumeType::operator=(const ResumeType& other9) {
  streamId = other9.streamId;
  position = other9.position;
  __isset = other9.__isset;
  return *this;
}
void ResumeType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResumeType(";
  out << "streamId=" << to_string(streamId);
  out << ", " << "position=" << to_string(position);
  out << ")";
}


StopType::~StopType() noexcept {
}

StopType::StopType() noexcept
   : streamId(),
     reason() {
}

void StopType::__set_streamId(const std::string& val) {
  this->streamId = val;
}

void StopType::__set_reason(const std::string& val) {
  this->reason = val;
}
std::ostream& operator<<(std::ostream& out, const StopType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StopType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->streamId);
          this->__isset.streamId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          this->__isset.reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StopType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StopType");

  xfer += oprot->writeFieldBegin("streamId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->streamId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StopType &a, StopType &b) {
  using ::std::swap;
  swap(a.streamId, b.streamId);
  swap(a.reason, b.reason);
  swap(a.__isset, b.__isset);
}

bool StopType::operator==(const StopType & rhs) const
{
  if (!(streamId == rhs.streamId))
    return false;
  if (!(reason == rhs.reason))
    return false;
  return true;
}

StopType::StopType(const StopType& other10) {
  streamId = other10.streamId;
  reason = other10.reason;
  __isset = other10.__isset;
}
StopType& StopType::operator=(const StopType& other11) {
  streamId = other11.streamId;
  reason = other11.reason;
  __isset = other11.__isset;
  return *this;
}
void StopType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StopType(";
  out << "streamId=" << to_string(streamId);
  out << ", " << "reason=" << to_string(reason);
  out << ")";
}


AudioInfoType::~AudioInfoType() noexcept {
}

AudioInfoType::AudioInfoType() noexcept
   : streamId() {
}

void AudioInfoType::__set_streamId(const std::string& val) {
  this->streamId = val;
}
std::ostream& operator<<(std::ostream& out, const AudioInfoType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AudioInfoType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->streamId);
          this->__isset.streamId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AudioInfoType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AudioInfoType");

  xfer += oprot->writeFieldBegin("streamId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->streamId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AudioInfoType &a, AudioInfoType &b) {
  using ::std::swap;
  swap(a.streamId, b.streamId);
  swap(a.__isset, b.__isset);
}

bool AudioInfoType::operator==(const AudioInfoType & rhs) const
{
  if (!(streamId == rhs.streamId))
    return false;
  return true;
}

AudioInfoType::AudioInfoType(const AudioInfoType& other12) {
  streamId = other12.streamId;
  __isset = other12.__isset;
}
AudioInfoType& AudioInfoType::operator=(const AudioInfoType& other13) {
  streamId = other13.streamId;
  __isset = other13.__isset;
  return *this;
}
void AudioInfoType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AudioInfoType(";
  out << "streamId=" << to_string(streamId);
  out << ")";
}


VideoType::~VideoType() noexcept {
}

VideoType::VideoType() noexcept
   : filename() {
}

void VideoType::__set_filename(const std::string& val) {
  this->filename = val;
}
std::ostream& operator<<(std::ostream& out, const VideoType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VideoType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filename);
          this->__isset.filename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VideoType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VideoType");

  xfer += oprot->writeFieldBegin("filename", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->filename);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VideoType &a, VideoType &b) {
  using ::std::swap;
  swap(a.filename, b.filename);
  swap(a.__isset, b.__isset);
}

bool VideoType::operator==(const VideoType & rhs) const
{
  if (!(filename == rhs.filename))
    return false;
  return true;
}

VideoType::VideoType(const VideoType& other14) {
  filename = other14.filename;
  __isset = other14.__isset;
}
VideoType& VideoType::operator=(const VideoType& other15) {
  filename = other15.filename;
  __isset = other15.__isset;
  return *this;
}
void VideoType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VideoType(";
  out << "filename=" << to_string(filename);
  out << ")";
}

} // namespace
